
import { collection, addDoc, serverTimestamp, getDocs, query, orderBy, limit } from 'firebase/firestore';
import { db } from '@/lib/firebase';
import type { Ticket } from '@/types/ticket';

/**
 * Creates a new support ticket within the user's specific company subcollection.
 * The ticket number is now generated by finding the last ticket number and incrementing it.
 * It also fetches the client's IP address.
 */
export async function createSupportTicket(
    data: Omit<Ticket, 'id' | 'ticketNumber' | 'status' | 'createdAt' | 'updatedAt' | 'requesterIp'>
): Promise<string> {
    const { requesterUid, requesterCompanyId } = data;

    if (!requesterUid || !requesterCompanyId) {
        throw new Error("UID do usuário e ID da empresa são obrigatórios.");
    }

    // Fetch client's IP address
    let clientIp = 'N/A';
    try {
        const response = await fetch('https://api.ipify.org?format=json');
        const ipData = await response.json();
        clientIp = ipData.ip;
    } catch (error) {
        console.error("Could not fetch IP address:", error);
    }

    const ticketsRef = collection(db, `users/${requesterUid}/companies/${requesterCompanyId}/tickets`);

    // Find the last ticket number to increment it.
    const q = query(ticketsRef, orderBy("ticketNumber", "desc"), limit(1));
    const lastTicketSnap = await getDocs(q);
    let lastNumber = 0;
    if (!lastTicketSnap.empty) {
        const lastTicketData = lastTicketSnap.docs[0].data();
        const numPart = lastTicketData.ticketNumber.split('-')[1];
        lastNumber = parseInt(numPart) || 0;
    }
    const newTicketNumber = `T-${String(lastNumber + 1).padStart(4, '0')}`;

    const newTicket: Omit<Ticket, 'id'> = {
        ...data,
        ticketNumber: newTicketNumber,
        requesterIp: clientIp,
        status: 'open',
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
    };

    await addDoc(ticketsRef, newTicket);
    return newTicketNumber;
}
